
## 一、是什么


## 二、准备工作

### 2.1 hello world

### 2.2 如果调用

### 2.3 开发者工具使用

## 三、讲解

###
















## 是什么

- 为什么叫 graphql
- GraphQL来自Facebook
- 嗯，和SQL一样，GraphQL是一门查询语言, GraphQL 是一种描述请求数据方法的语法
- 同样和SQL一样的是，GraphQL也是一套规范，就像MySQL是SQL的一套实现一样，Apollo, Relay...也是GraphQL规范的实现
- 与SQL不同的是，SQL的数据源是数据库，而GraphQL的数据源可以是各种各样的REST API，可以是各种服务/微服务，甚至可以是数据库
- GraphQL规范于2015年开源
- 那么为什么叫 Graph呢？
- GraphQL 是一种用于 API 的查询语言
- GraphQL 是一种面向数据的 API 查询风格
- 出生: 2015, 父亲: Facebook
- (已开源)2018 年 11 月 7 日，Facebook 将 GraphQL 项目转移到新成立的 GraphQL 基金会
- 传统的 API 拿到的是前后端约定好的数据格式，GraphQL 对 API 中的数据提供了一套易于理解的完整描述，客户端能够准确地获得它需要的数据，没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具
- 讲故事: 问题, 解决方案 https://juejin.cn/post/6844903475420069902
- 名称中的 “Graph” 是来自于 GraphQL 使用字段与子字段来遍历你的 API 图谱；“QL” 的意思是“查询语言”（query language）。

## 概述

- 理论上，一个 GraphQL API 主要由三个部分组成：schema（类型），queries（查询） 以及 resolvers（解析器）

为什么要出现 QL, QL 简单举个例子？？给个图

## 解决了什么

- 它允许客户端指定具体所需的数据。
- 它让从多个数据源汇总取数据变得更简单。
- 它使用了类型系统来描述数据。
- API字段的定制化，按需取字段
- API的聚合，一次请求拿到所有的数据
- 后端不再需要维护接口的版本号了(随意添加、通过修饰符标记为废弃)
- 完备的类型校验机制，提供了更健壮的接口
- 精准、可预测地返回数据: REST 后端给你什么我就要什么, 尤其是历史悠久的接口, 传统的 RESTful 接口, 后端传递多少字段, 前端就得接收多少字段. 因此, 有时候前端只需要几个字段, 但后端返回一大串(尤其是历史悠久的接口), 这不但对前端筛选接口字段增加了难度, 还可能会造成潜在的性能问题. 而 GraphQL 使得客户端能够准确地获得它需要的数据, 而且没有任何冗余, 并且 GraphQL 筛选这些字段的过程不依赖于服务器, 而是它自己运行时
- 只请求一个接口
- GraphQL 不依赖于任何编程语言, 他只是一个规范, 至于使用什么语言、如何实现就完全自由
- 如果使用 GraphQL，那么后端将不再产出 API，而是将 Controller 层维护为 Resolver，和前端约定一套 Schema，这个 Schema 将用来生成接口文档，前端直接通过 Schema 或生成的接口文档来进行自己期望的请求
- 正如尤雨溪所说，为什么 GraphQL 两三年前没有广泛使用起来呢，可能有下面两个原因：

> GraphQL 的 field resolve 如果按照 naive 的方式来写，每一个 field 都对数据库直接跑一个 query，会产生大量冗余 query，虽然网络层面的请求数被优化了，但数据库查询可能会成为性能瓶颈，这里面有很大的优化空间，但并不是那么容易做。FB 本身没有这个问题，因为他们内部数据库这一层也是抽象掉的，写 GraphQL 接口的人不需要顾虑 query 优化的问题。
GraphQL 的利好主要是在于前端的开发效率，但落地却需要服务端的全力配合。如果是小公司或者整个公司都是全栈，那可能可以做，但在很多前后端分工比较明确的团队里，要推动 GraphQL 还是会遇到各种协作上的阻力。

## 几个重要概念

1. 操作类型: 描述客户端当前希望进行怎么样的操作

query 查询：获取数据，比如查找，CRUD 中的 R
mutation 变更：对数据进行变更，比如增加、删除、修改，CRUD 中的 CUD
substription 订阅：当数据发生更改，进行消息推送

2. 对象类型和标量类型

如果一个 GraphQL 服务接受到了一个 query，那么这个 query 将从 Root Query 开始查找，找到对象类型（Object Type）时则使用它的解析函数 Resolver 来获取内容，如果返回的是对象类型则继续使用解析函数获取内容，如果返回的是标量类型（Scalar Type）则结束获取，直到找到最后一个标量类型。

对象类型：用户在 schema 中定义的 type
标量类型：GraphQL 中内置有一些标量类型 String、Int、Float、Boolean、ID，用户也可以定义自己的标量类型

3. 模式 Schema

它定义了字段的类型、数据的结构，描述了接口数据请求的规则，当我们进行一些错误的查询的时候 GraphQL 引擎会负责告诉我们哪里有问题，和详细的错误信息，对开发调试十分友好。
Schema 使用一个简单的强类型模式语法，称为模式描述语言（Schema Definition Language, SDL），我们可以用一个真实的例子来展示一下一个真实的 Schema 文件是怎么用 SDL 编写的：

这个简单的 Schema 文件从 Query、Mutation、Subscription 入口开始定义了各个对象类型或标量类型，这些字段的类型也可能是其他的对象类型或标量类型，组成一个树形的结构，而用户在向服务端发送请求的时候，沿着这个树选择一个或多个分支就可以获取多组信息。
注意：在 Query 查询字段时，是并行执行的，而在 Mutation 变更的时候，是线性执行，一个接着一个，防止同时变更带来的竞态问题，比如说我们在一个请求中发送了两个 Mutation，那么前一个将始终在后一个之前执行。

4. 解析函数 Resolver

前端请求信息到达后端之后，需要由解析函数 Resolver 来提供数据，比如这样一个 Query

解析函数接受四个参数，分别为

parent：当前上一个解析函数的返回值
args：查询中传入的参数
context：提供给所有解析器的上下文信息
info：一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值

5. 请求格式

GraphQL 最常见的是通过 HTTP 来发送请求，那么如何通过 HTTP 来进行 GraphQL 通信呢
Get 是将请求内容放在 URL 中，Post 是在 content-type: application/json 情况下，将 JSON 格式的内容放在请求体里

- Get 方式
http://myapi/graphql?query={me{name}}

- Post 方式的请求体

{
  "query": "...",
  "operationName": "...",
  "variables": { "myVariable": "someValue", ... }
}

- 返回格式

```json
# 正确返回
{
  "data": { ... }
}

# 执行时发生错误
{
  "errors": [ ... ]
}
```

## 案例学习

- 前端如何调用查询? `axios` `curl` `fecth` `REST CLIENT`
- 常见查询？
- 基于 koa + Apollo 实现一个后台服务？
- 场景假设:
 1. 在线会议室(、shareId、title、desc、where、startTime)
 2. 有个会议列表页(分页)
 2. 有个详情页(3 个接口): 获取分享详情、获取分享的评论列表、获取分享者所有的分享列表
- 场景假设:
	例如，假设你要展示一个文章（posts）列表，在每篇文章的下面显示喜欢这篇文章的用户列表（likes），其中包括用户名和用户头像。这个需求很容易解决，你只需要调整你的 posts API 请求，在其中嵌入包括用户对象的 likes 列表，如下所示：
	现在我们再掺入另一种情况：posts 数据是由 MySQL 数据库存储的，而 likes 数据却是由 Redis 存储的。现在你该怎么办？按着这个剧本想一想 Facebook 的客户端有多少个数据源和 API 需要管理，你就知道为什么现在评价很好的 REST API 所体现出的局限性了

- 服务端一个例子, 给出所有标量(Int, Float, String, Boolean, ID 五种)、Scalar、Enum(枚举)、Interfaces(接口)、
- Query 和 Mutation 是两个内置的特殊类型

## 后台功能实现

## 补充知识

1. 别名可用于任何字段, 比如

```ql
query findAllShares {
  # 为 shares 起个别名, sharesA
	sharesA: shares {
		shareId: id # 为 id 起了一个别名，叫 shareId
	}
}
```

2. 每一个schema有一个根(root)query和根(root)mutation

3. GraphQL约定，我们需要为Root Query（根查询）和Root Mutation（根变更）里面的每一个字段提供一个resolver的函数。并包装成一个对象暴露出去

4. Introspection
  在真实的开发中, 我们会在后端定义一系列的 query, mutation, input, type, enum, scalar, interface. 而 GraphQL 支持一套强大的内省系统, 通过内省系统, 我们可以反查后端设计的 schema 的集合. 内省系统的另一个功能则是辅助开发 GraphQL 工具, 通过查询出来的内部 schema, 可以搭建出强大的 IDE. 如下代码可以查询出 PostItemModel 这个类型的所有信息

5. 安全

- 生产环境关闭 debug， 如果开启 debug 模式, 在出错时会展示错误的堆栈信息.
- 生产环境关闭 playground，playground 应当作为一种辅助自测工具, 其不应该暴露到线上.
- 生产环境关闭 introspection， 得益于自省, 可以轻松获取到 GraphQL server 内部的信息, 如各种类型, 标量等. 这些信息不应该在线上被三方直接通过代码采集到.
- 控制多层深度的查询: 如下可能会造成昂贵的查询, 重则导致后端崩溃. 可以使用 graphql-depth-limit 来指定最多查询的层级.
- 控制分页数据量: 如下最多一次将能获取十万条数据, 显而易见会带来性能问题. 你可以通过 graphql-input-number 在 resolver 中限制数字的最大值

6. substription 订阅：当数据发生更改，进行消息推送

> https://www.apollographql.com/docs/apollo-server/v2/features/subscriptions.html#subscription-filters

```js
# src/schema.graphql

# Subscription 入口
type Subscription {
    subsUser(id: ID!): User
}

type User {
    id: ID!
    name: String!
    age: Int
    email: String!
}
```

```js
// src/resolvers/index.js
import Db from '../db'
const { PubSub, withFilter } = require('apollo-server')
const pubsub = new PubSub()
const USER_UPDATE_CHANNEL = 'USER_UPDATE'

export default {
    Mutation: {
        updateUser: (parent, { id, name, email, age }) => Db.user({ id })
            .then(existUser => {
                if (!existUser)
                    throw new Error('没有这个id的人')
                return existUser
            })
            .then(() => Db.updateUser({ id, name, email, age }))
            .then(user => {
                pubsub.publish(USER_UPDATE_CHANNEL, { subsUser: user })
                return user
            })
    },
    Subscription: {
        subsUser: {
            subscribe: withFilter(
                (parent, { id }) => pubsub.asyncIterator(USER_UPDATE_CHANNEL),
                (payload, variables) => payload.subsUser.id === variables.id
            ),
            resolve: (payload, variables) => {
                console.log('🚢 接收到数据： ', payload)
            }
        }
    }
}
```

## 参考

- https://juejin.cn/post/6844903811006332935#heading-10
- https://juejin.cn/post/7012133339037450271
- [GraphQL 从入门到实践](https://juejin.cn/post/6844903795407716366#comment)
- [我经常听到的 GraphQL 到底是什么](https://juejin.cn/post/6844903475420069902)

